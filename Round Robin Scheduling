# Round Robin Scheduling

n = int(input("Enter the Number of Processes: "))
arrival_time = []
burst_time = []
processes = [f"P{i+1}" for i in range(n)]

for i in range(n):
    at = int(input(f"Enter the Arrival Time for process {processes[i]}: "))
    bt = int(input(f"Enter the Burst Time for process {processes[i]}: "))
    arrival_time.append(at)
    burst_time.append(bt)

quantum = int(input("Enter the Time Quantum: "))

remaining_time = burst_time[:]
waiting_time = [0] * n
turnaround_time = [0] * n
completion_time = [0] * n

time = 0
queue = []
visited = [False] * n
completed = 0

while completed < n:
    for i in range(n):
        if arrival_time[i] <= time and not visited[i] and remaining_time[i] > 0:
            queue.append(i)
            visited[i] = True

    if not queue:
        time += 1
        continue

    idx = queue.pop(0)

    if remaining_time[idx] > quantum:
        time += quantum
        remaining_time[idx] -= quantum
    else:
        time += remaining_time[idx]
        remaining_time[idx] = 0
        completion_time[idx] = time
        turnaround_time[idx] = completion_time[idx] - arrival_time[idx]
        waiting_time[idx] = turnaround_time[idx] - burst_time[idx]
        completed += 1

    for i in range(n):
        if arrival_time[i] <= time and not visited[i] and remaining_time[i] > 0:
            queue.append(i)
            visited[i] = True

    if remaining_time[idx] > 0:
        queue.append(idx)

print("\nProcess\tArrival Time\tBurst Time\tWaiting Time\tTurnaround Time")
for i in range(n):
    print(f"{processes[i]}\t\t{arrival_time[i]}\t\t{burst_time[i]}\t\t{waiting_time[i]}\t\t{turnaround_time[i]}")

avg_wt = sum(waiting_time) / n
avg_tat = sum(turnaround_time) / n
print(f"\nAverage Waiting Time: {avg_wt}")
print(f"Average Turnaround Time: {avg_tat}")
